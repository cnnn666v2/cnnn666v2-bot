

/**
 * Parse MS to multiple durations 
 * @param {Number} ms - The milliseconds
 * @example parseMS(3600000)
 */
function parse(ms) {
    if (isNaN(ms)) throw new TypeError("MS is not a number, received " + ms + " ( " + typeof ms + " )")
    let second = Math.trunc(ms / 1000)
    
    let seconds = second > 59 ? second - (Math.trunc(second / 60) * 60) : second
     let minutes = second > 59 ? Math.trunc( second / 60 ) : 0 
     let hours = minutes > 59 ? Math.trunc( minutes / 60 ) : 0
     let days = hours > 23 ? Math.trunc( hours / 24 ) : 0
     let months = days > 29 ? Math.trunc( days / 30 ) : 0 
     let years = months > 11 ? Math.trunc( months / 12 ) : 0
     
     if (minutes > 59) {
       minutes = minutes - (minutes - 60 > 0 ? ( Math.trunc(minutes/60) * 60) : 60)
  
     }
  
    if (hours > 23) {
      hours = hours - (hours - 24 > 0 ? (Math.trunc(hours / 24) * 24) : 24)
  
    }
  
    if (days > 29) {
      days = days - (days - 30 > 0 ? (Math.trunc( days / 30 ) * 30 ) : 30)
    }
  
    if ( months > 11) {
      months = months - (months - 12 > 0 ? (Math.trunc( months / 12 ) * 12) : 12)
    }
  
    let ParsedMS = {
      second:seconds,
      minute:minutes,
      hour:hours,
      day:days,
      month:months,
      year:years,
      /**
       * Returns an Array of Converted 
       * @param {boolean} [addTimeago]
       */
      array: (add_And = true) => {
        let array = []
        let I = false
        for (const k of Object.keys(ParsedMS).reverse()) {
        if (typeof ParsedMS[k] === "number" && ParsedMS[k] > 0) {
          array.push(`${add_And === true && array.length > 0 && Object.keys(ParsedMS).reverse().filter(f => (typeof ParsedMS[f] === "number" && ParsedMS[f] > 0))[Object.keys(ParsedMS).reverse().filter(f => (typeof ParsedMS[f] === "number" && ParsedMS[f] > 0)).length - 1] === k ? "and " : ""}${ParsedMS[k]} ${k}${ParsedMS[k] > 1 ? "s" : ""}`)
        } else {
          continue
        }
        
        }
        return array
      },
      /**
       * Returns a String in Ago Timestamp
       */
      timeago: () => {
        const array = ParsedMS["array"]()
        let res = array[0] 
        if (array[1]) {
            res = `${array[0]} and ${array[1]} ago`
        } else {
            res = res + " ago"
        }
        return res
    },
    /**
     * Returns a Joined Array of String based of Separator
     * @param {string} separator 
     */
    toString: (separator = ", ") => {
        if (typeof separator !== "string") {
          throw new TypeError("Separator must be typeof String!")
        }
        const array = ParsedMS["array"]()
    
        return array.join(separator)
      }
    }
  
    
    
    return ParsedMS
  }
  
  module.exports = parse