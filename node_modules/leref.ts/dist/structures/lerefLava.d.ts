import { LerefNodes } from "./lerefNodes";
import { LerefPlayer } from "./lerefPlayer";
import { LavaOptions, NodeOptions, PlayerOptions, ResumeConfig, SearchQuery, SearchResult } from "../utils/typings";
import { TypedEmitter } from "tiny-typed-emitter";
import { TrackEndPayload, TrackExceptionPayload, TrackStartPayload, TrackStuckPayload, VoiceServerUpdate, VoiceStateUpdate, WebSocketClosedPayload } from "../utils/payloads";
import { LerefTracking, UnresolvedTrack } from "./lerefTracking";
import { TrackData, Tracks } from "../utils/rest";
export interface LavaEvents {
    /** Emitted when a node is created */
    nodeCreate(node: LerefNodes): void;
    /** Emitted when a node is destroyed */
    nodeDestroy(node: LerefNodes): void;
    /** Emitted when a node connects */
    nodeConnect(node: LerefNodes): void;
    /** Emitted when a Node reconnects */
    nodeReconnect(node: LerefNodes): void;
    /** Emitted when a Node disconnects */
    nodeDisconnect(node: LerefNodes, reason: {
        code: number;
        reason: string;
    }): void;
    /** Emitted when a Node has an error */
    nodeError(node: LerefNodes, error: Error): void;
    /** Emitted whenever any Lavalink event is received */
    nodeRaw(node: LerefNodes, payload: unknown): void;
    /** Emitted whenever a Player is created */
    playerCreate(player: LerefPlayer): void;
    /** Emitted whenever a Player is destroyed */
    playerDestroy(player: LerefPlayer): void;
    /** Emitted whenever a Player is replaying after moving node */
    playerReplay(player: LerefPlayer): void;
    /** Emitted whenever an error occured when replaying track */
    replayError(player: LerefPlayer, error: Error): void;
    /** Emitted whenever a Player is moved to other channel */
    playerMove(player: LerefPlayer, oldChannel: string | undefined, newChannel: string | undefined): void;
    /** Emitted whenever queue is started */
    queueStart(player: LerefPlayer, track: LerefTracking | UnresolvedTrack, payload: TrackStartPayload): void;
    /** Emitted whenever queue is ended */
    queueEnd(player: LerefPlayer, track: LerefTracking | UnresolvedTrack, payload: TrackEndPayload): void;
    /** Emitted whenever a track start */
    trackStart(player: LerefPlayer, track: LerefTracking | UnresolvedTrack, payload: TrackStartPayload): void;
    /** Emitted whenever a track end */
    trackEnd(player: LerefPlayer, track: LerefTracking | UnresolvedTrack, payload: TrackEndPayload): void;
    /** Emitted whenever a track stuck during playback */
    trackStuck(player: LerefPlayer, track: LerefTracking | UnresolvedTrack, payload: TrackStuckPayload): void;
    /** Emitted whenever a track occur an error during playback */
    trackError(player: LerefPlayer, track: LerefTracking | UnresolvedTrack, payload: TrackExceptionPayload): void;
    /** Emitted whenever a voice connection is closed */
    socketClosed(player: LerefPlayer, payload: WebSocketClosedPayload): void;
}
/**
 * The main hub for interacting with Lavalink and using leref.ts
 */
export declare class LerefLava extends TypedEmitter<LavaEvents> {
    clientID?: string;
    options: LavaOptions;
    readonly nodes: Map<string, LerefNodes>;
    readonly players: Map<string, LerefPlayer>;
    constructor(options: LavaOptions);
    get leastUsedNode(): LerefNodes | undefined;
    get leastLoadNode(): LerefNodes | undefined;
    /** Initiate the Lavalink client */
    init(clientID: string): void;
    /** Searches some tracks based off the URL or the `source` property */
    search(query: SearchQuery, requester?: unknown): Promise<SearchResult>;
    /** Decode the base64 track into TrackData */
    decodeTrack(track: string): Promise<TrackData>;
    /** Decode the base64 tracks into TracksData */
    decodeTracks(tracks: string[]): Promise<Tracks>;
    /** Send voice data to the Lavalink server */
    updateVoiceData(p: VoiceServerUpdate | VoiceStateUpdate): void;
    /** Configure the resume config */
    configResume(config: ResumeConfig): void;
    /** Create a player or return one if it already exists */
    create(options: PlayerOptions): LerefPlayer;
    /** Return a player or undefined if it doesn't exist */
    get(guildID: string): LerefPlayer | undefined;
    /** Destroy a player if it exist */
    destroy(guildID: string): void;
    /** Add a node */
    add(nodeOptions: NodeOptions): void;
    private handleEvent;
    private sortAndGetFirstNode;
}
