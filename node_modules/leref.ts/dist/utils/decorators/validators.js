"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.check = exports.Queue = exports.decorateMethod = void 0;
const lerefTracking_1 = require("../../structures/lerefTracking");
function decorateMethod(func) {
    return function decorate(_0, _1, descriptor) {
        const method = descriptor.value;
        descriptor.value = function (...args) {
            return func.apply(this, [method.bind(this), ...args]);
        };
        return descriptor;
    };
}
exports.decorateMethod = decorateMethod;
var Queue;
(function (Queue) {
    function validateTracks() {
        return decorateMethod(function (func, trackOrTracks, offset) {
            const error = new TypeError("Parameter 'trackOrTracks' must be present and be a LerefTracking or UnresolvedTrack");
            if (Array.isArray(trackOrTracks) && trackOrTracks.length) {
                for (const track of trackOrTracks) {
                    if (!(lerefTracking_1.LerefTracking.isTrack(track) || lerefTracking_1.UnresolvedTrack.isUnresolved(track)))
                        throw error;
                }
            }
            else if (!(lerefTracking_1.LerefTracking.isTrack(trackOrTracks) || lerefTracking_1.UnresolvedTrack.isUnresolved(trackOrTracks))) {
                throw error;
            }
            if (typeof offset !== "undefined" && typeof offset === "number") {
                if (Number.isNaN(offset))
                    throw new TypeError("Parameter 'offset' must be a number");
                if (offset < 0 || offset > this.length)
                    throw new RangeError(`Offset must be or between 0 and ${this.length}`);
            }
            return func(trackOrTracks);
        });
    }
    Queue.validateTracks = validateTracks;
    function validatePosition() {
        return decorateMethod(function (func, start, end) {
            if (typeof start !== "number" ||
                isNaN(start))
                throw new TypeError("Parameter 'start' must be present and be a number");
            if (start >= this.length)
                throw new RangeError(`Parameter 'start' can not be bigger than ${this.length}`);
            if (typeof end !== "undefined") {
                if (typeof end !== "number" || isNaN(end))
                    throw new TypeError("Parameter 'end' must be a number");
                if (start >= end)
                    throw new RangeError("Parameter 'start' can not be bigger than end");
            }
            return func(start, end);
        });
    }
    Queue.validatePosition = validatePosition;
})(Queue = exports.Queue || (exports.Queue = {}));
function check(func) {
    return decorateMethod(func);
}
exports.check = check;
